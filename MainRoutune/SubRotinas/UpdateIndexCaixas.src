DEF UpdateIndexCaixas ( )
   ;{PalletAtivo} numero da esteira que está com a caixa
   ;{CLPNumCaixas} numero de caixas para o pick
   ;{CLPIndexacaoVH} TRUE-> Vertical / FALSE -> Horizontal
   ;INT PalletAtivo=1
   ;INT  CLPNumCaixas    
   ;BOOL CLPIndexacaoVH  
   SaidaLoop = FALSE
   
   REPEAT
      ;precisa saber qual o pallet ativo
      ;atravez do pallet ativo o programa sabe qual mozaico está selecionado
      ;verifica se eh primeiro place
      
      ;VERIFICA CAIXA E CAMADA      
      ;->apos colocar a caixa deve acrescentar + 1 em
      ProximoPlace=StrPallet[PalletAtivo].PlaceAtivo + 1
      ProximaCamada=StrPallet[PalletAtivo].CamadaAtiva
      
      ;->se a qtd de caixas da camada for acima da qtd do mozaico deve-se subir a camada
      IF ProximoPlace > StrReceita[ReceitaAtivo].PlacesCamada THEN
         ProximoPlace=1 ;verificar aqui se deve comecar com 1 ou 0
         ProximaCamada=StrPallet[PalletAtivo].CamadaAtiva + 1
      ENDIF
      ;->se a qtd de camadas do pallet for acima da qtd do mozaico
      IF ProximaCamada > StrReceita[ReceitaAtivo].Camadas THEN
         ;Envia alerta de Pallet concluido
         ProximoPlace = 1
         ProximaCamada = 1
         SaidaLoop = FALSE
         EXIT
      ENDIF
      
      ProxPlacesCamada = StrReceita[ReceitaAtivo].PlacesCamada
      ProxLayer = StrReceitaLayer[ReceitaAtivo,ProximaCamada]
      ProxPlaceLayer = ProximoPlace + ProxPlacesCamada*(ProxLayer-1)
      
      IF (MatrizPontos[PalletAtivo,ReceitaAtivo,ProxPlaceLayer].SkipGoHome == TRUE) THEN
         SaidaLoop = TRUE
      ENDIF 
      IF (MatrizPontos[PalletAtivo,ReceitaAtivo,ProxPlaceLayer].SkipGoHome == FALSE) AND (SaidaLoop == TRUE)  THEN
         SaidaLoop = FALSE
      ENDIF
      
   UNTIL (SaidaLoop == FALSE)
   
   ;SaidaLoop
   IndexacaoVH = MatrizPontos[PalletAtivo,ReceitaAtivo,ProxPlaceLayer].IndexacaoVH
   NumCaixas = MatrizPontos[PalletAtivo,ReceitaAtivo,ProxPlaceLayer].NumCaixas  
   
END